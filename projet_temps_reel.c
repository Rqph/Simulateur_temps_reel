/***********************************************************************/
/*                                                                     */
/*  FILE        :test_compil.c                                         */
/*  DATE        :Fri, Sep 29, 2006                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :87                                                    */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.5).     */
/*   m308															   */
/*   nc308lib														   */
/*   c308mr															   */
/*   nc382lib														   */
/*                                                                     */
/***********************************************************************/
#include "sfr32c87.h"
#include <stdio.h>
#include <stdlib.h>
#include <itron.h>
#include <kernel.h>
#include "kernel_id.h"
#include "lcd.h"
#include "clavier.h"
#include "periph.h"
#include "uart0.h"
#include "can.h"
#include "carte_io.h"
#include "carte_m32.h"
#include <math.h>

// Potentiometre: lire les registres ad00 et ad01, les valeurs sont sur 10 bits.

// Clavier: vrcv_dtq(QdmTouche,&code_touche) pour lire la derniere touche appuyee sur le clavier.
// 			la variable code_touche doit etre du type short.

// Bouton poussoir: Bp_G, Bp_M, Bp_D permettent de lire l'etat des boutons de la carte I/O

// Leds: LED_R=1 ou LED_R=0 Pour allumer ou eteindre les leds (LED_R, LED_J, LED_V).

// Pour communiquer avec le simulateur utiliser une variable de type CanFrame,
// Definir les differents champs en utilisant la structure (S)eparee (comm.data)
// Envoyer le message complet en utilisant l'union (comm.msg)

// Exemple:
// 		CanFrame comm;
//			comm.data.id='T'; comm.data.rtr=0; comm.data.val=-100;
//			snd_dtq (CanTx,comm.msg);

// Pour interroger un peripherique et recuperer les donnees brutes renvoyees simulateur:
//		CanFrame demande;
//		CanFrame reponse;
//
//			demande.data.id='R'; demande.data.rtr=1;
//			snd_dtq (CanTx,demande.msg); // Interrogation du peripherique
// 			rcv_dtq (CanRx,&reponse.msg); // Attente de la reponse
// 			reponse.data.val contient la valeur de retour du simulateur.
// ATTENTION: Ne pas utiliser rcv_dtq(CanRx... si la tache ID_periph_rx est active

// Lors de l'utilisation de la tache de reception et distribution des messages ID_periph_rx
// Demarrer cette tache : sta_tsk(ID_periph_rx);
// Pour lire la valeur d'un peripherique:
// Il faut envoyer une demande de lecture:
// 	CanFrame comm;
// 		comm.data.id='R'; comm.data.rtr=1;
// 		snd_dtq (CanTx,comm.msg);
//
// Des l'arrivee de la reponse du simlateur, les variables suivantes sont mises a jour:
// periph[ADDR('R')].val : contient la derniere valeur renvoyee par le simulateur.
//
// Pour verifier si une nouvelle valeur a ete recue utiliser:
// periph[ADDR('R')].maj (incremente a chaque reception).

// Pour qu'un evenement soit declenche lors de la reception d'une donnee pour un peripherique:
// periph[ADDR('R')].ev=0x01;
// Pour se mettre en attente de l'evenement: wai_flg (ev_periph,0x0001,TWF_ORW,&flag); // Declarer la variable flag comme : FLGPTN flag
// Attention l'evenement n'est pas efface apres reception, il faut donc utiliser clr_flg(ev_periph,~(flag & 0x0001)); par example

// Les evenements:
// Si le simulateur envoi un evenement sur 16 bits il est recu grace a:
// par exemple:  wai_flg(event,(FLGPTN) 0x0007,TWF_ORW,&flag); // Declarer la variable flag comme : FLGPTN flag
// Attention l'evenement n'est pas efface apres reception, il faut donc utiliser clr_flg(event,~(flag & 0x0007)); par example
//Bit   Information associee            Remarque
//0     Capteur Vert,                   remis a zero lors de la lecture du peripherique 'C'
//1     Capteur Jaune,                  remis a zero lors de la lecture du peripherique 'C'
//2     Capteur Rouge,                  remis a zero lors de la lecture du peripherique 'C'
//3     Capteur Bleu,                   remis a zero lors de la lecture du peripherique 'C'
//4     Capteur Cyan,                   remis a zero lors de la lecture du peripherique 'C'
//5
//6     Collision avec le sol,          remise a zero au changement de piste.
//7     Fin de course (capteur vert),   remis a zero lors de la lecture du peripherique 'C'
//8     La piste a change ,             remis a zero lors de la lecture du peripherique 'M'
//9     Le mode de course a change ,    remis a zero lors de la lecture du peripherique 'M'
//10
//11    Le vehicule a termine un tour,   remis a zero au changement du mode de course.
//12    Sortie de la piste,
//13    Teleportation a ete utilisee,   remis a zero au changement de piste ou du mode de course.
//14    Faux depart                     remise a zero au changement du mode de course.
//15


// Peripheriques disponibles:
//'V'/86/0x56 : Commande en vitesse des roues motrices du vehicule (en radian /secondes).
//'D'/68/0x44 : Commande de l'angle des roues directrices (en 1/10 de degre).
//'T'/84/0x54 : Commande en vitesse de la tourelle portant le telemetre (en 1/10 de degre/secondes).
//'R'/82/0x52 : Lecture de l'angle effectif de la tourelle portant le telemetre (en 1/10 de degre).
//'U'/85/0x55 : Distance mesuree par le telemetre (1/100 de metre)
//'N'/78/0x4E : Numero de la voiture (en fonction de l'ordre de connexion)
//'E'/69/0x45 : Lecture des evenements,
//'H'/72/0x48 : Donne le temps de course actuel
//'S'/83/0x53 : Temps du tour precedent
//'M'/77/0x7D : Mode de course :
//  Bit 15 : Etat feu tricolore ( 1 -> Vert, 0 -> Orange ou Rouge),
//  Bits 14-8 : 1 Attente, 2 course, 3 essais libres)
//  Bits 7-0 : numero de la piste
//'C'/67/0x43 : Informations sur le dernier capteur touche :
//  8 bits de poids faible : numero du capteur
//  8 bits de poids fort : couleur ('C','R','J','B' ou 'V')
//'J'/74/0x4A : Proposition d'un code de dévérouillage. 
//				Une valeur de 0 à 5 par quartet
//'j'/106/06A : Récupération du résultat de dernier code envoyé. 
//				0x77 si aucun code n'a été soumis. 
//				<0 si la réponse n'est pas
//				disponible. 0x0a0b avec a-> nombre de couleurs bien placées et b -> couleurs présentes mais mal placées.
//'I'/73/Ox49 : Définition du nom du véhicule. Doit débuter par le caractère '#' et entraine le chargement de la configuration de piste
//				correspondant au nom du véhicule si le nom se termine par '*'

void regu_tourelle()
{
	CanFrame comm;
	CanFrame requete;
	unsigned short alpha, eps, consigne = 450;
	while(1)
	{
		requete.data.id = 'R';
		requete.data.rtr = 1; // Indique une requête de lecture
		snd_dtq(CanTx, requete.msg);
		dly_tsk(25);
		if (periph[ADDR('R')].maj >0){
			alpha = periph[ADDR('R')].val;
			periph[ADDR('R')].maj=0;
		}
		eps = consigne-alpha;
		comm.data.id = 'T';
		comm.data.rtr = 0; // Indique une écriture
		comm.data.val = eps;
		snd_dtq(CanTx, comm.msg);
	
	}
}

void regu_roue()
{
	CanFrame comm;
	CanFrame requete;
	unsigned short distance, eps, consigne;
	while(1)
	{
		consigne = 500;
		requete.data.id = 'U';
		requete.data.rtr = 1; // Indique une requête de lecture
		
		snd_dtq(CanTx, requete.msg);
		dly_tsk(25);
		if (periph[ADDR('U')].maj >0){
			distance = periph[ADDR('U')].val*0.7;
			periph[ADDR('U')].maj=0;
		}
		
		eps = distance-consigne;
		comm.data.id = 'D';
		comm.data.rtr = 0; // Indique une écriture
		comm.data.val = eps;
		snd_dtq(CanTx, comm.msg);
	}
}

short decode_int(char c){
	short res;
	if (c < 48 || c > 57){
		res = -1;
	}
	else {
		res = c-48;
	}
	return res;
}

short decode_chaine(char str[]){
	short i=0,nb=0;
	while(str[i]!='\0'){
		nb = nb*10;
		nb = nb + decode_int(str[i]);
		i++;
	}
	return nb;
}
void affiche_touche(){
	CanFrame comm;
	int i;
	char str[4];
	short t,vitesse;
	while(1){
		vrcv_dtq(QdmTouche,&t);
		if (t == '#'){
			i = 0;
			lcd_cls();
			while(t != '*'){
				vrcv_dtq(QdmTouche,&t);
				str[i]=t;
				i++;
			}
			str[i-1]='\0';
			lcd_str(str);
			vitesse = decode_chaine(str);
			comm.data.id = 'V';
			comm.data.rtr = 0; 
			comm.data.val = vitesse;	
			snd_dtq(CanTx, comm.msg);
		}
	}
}

void info_temps(){
	CanFrame requete1,requete2;
	char str[20];
	int value;
	int value_old;
	while(1)
	{
		requete1.data.id = 'H';
		requete1.data.rtr = 1; // Indique une requête de lecture
		requete2.data.id = 'S';
		requete2.data.rtr = 1; // Indique une requête de lecture
		snd_dtq(CanTx, requete1.msg);
		snd_dtq(CanTx, requete2.msg);
		dly_tsk(100);
		if (periph[ADDR('H')].maj >0){
			value = periph[ADDR('H')].val;
			if (value >0){
				lcd_cls();
				sprintf(str, "%d", value);
				lcd_str("tps t :");
				lcd_str(str);
			}
		}
		if (periph[ADDR('S')].maj >0){
			value = periph[ADDR('S')].val;
			if (value >0)
			{
				if (value != value_old) {
					lcd_cls();
					sprintf(str, "%d", value);
					lcd_str("Tps prcdt :");
					lcd_str(str);
					value_old = value;
				}	
			}		
		}		
	}
}

void info_piste(){
	CanFrame requete;
	char str[20];
	int value, masque = 0x00FF;
	int LB;
	int value_old;
	while(1)
	{
		requete.data.id = 'M';
		requete.data.rtr = 1; // Indique une requête de lecture
		snd_dtq(CanTx, requete.msg);
		dly_tsk(100);
		if (periph[ADDR('M')].maj >0){
			value = periph[ADDR('M')].val;
			LB = value & masque;
			sprintf(str, "%d", LB);
			lcd_str("piste : ");
			lcd_str(str);	
			ext_tsk();
		}
	}
}

void lect_capt(){
	CanFrame comm;
	CanFrame requete;
	char str[20];
	int value, masque = 0x00FF;
	int LB,HB;
	int value_old;
	while(1)
	{
		requete.data.id = 'C';
		requete.data.rtr = 1; // Indique une requête de lecture
		snd_dtq(CanTx, requete.msg);
		dly_tsk(100);
		if (periph[ADDR('C')].maj >0){
			value = periph[ADDR('C')].val;
			if (value != value_old) {
				lcd_cls();
				LB = value & masque;
				sprintf(str, "%d", LB);
				lcd_str(str);
				lcd_putc('/');
				HB = (value>>8) & masque;
				sprintf(str, "%c", HB);
				lcd_str(str);
				value_old = value;
			}
		}
	}

}

void depart(){
	CanFrame requete,comm;
	int masque = (1<<15),feu;
	while(1){
		requete.data.id = 'M';
		requete.data.rtr = 1; // Indique une requête de lecture
		snd_dtq(CanTx, requete.msg);
		dly_tsk(25);
		if (periph[ADDR('M')].maj >0){
			feu = periph[ADDR('M')].val;
			if(feu & masque){
				comm.data.id = 'V';
				comm.data.rtr = 0; 
				comm.data.val = 20;	
				snd_dtq(CanTx, comm.msg);
				ext_tsk();
			}
			else {
				comm.data.id = 'V';
				comm.data.rtr = 0; 
				comm.data.val = 0;	
				snd_dtq(CanTx, comm.msg);
			}
			periph[ADDR('M')].maj=0;
			
		}	
	}
}

void urgence() 
{    
    CanFrame comm; 
    CanFrame requete;
    int restart = 0;
    while(1){
        dly_tsk(10);
        if(Bp_G == 1){
            comm.data.id = 'V';
            comm.data.rtr = 0;
            comm.data.val = 0;  
            snd_dtq(CanTx, comm.msg);
            restart = 1;
            LED_R=1;
        }
        if(Bp_G == 0 && restart == 1){
            LED_R = 0;
            comm.data.id = 'V';
            comm.data.rtr = 0;
            comm.data.val = 10;  
            snd_dtq(CanTx, comm.msg);
            restart = 0;
        }
    }
}

void main()
{
	CanFrame radar,comm,requete,comm2,reponse;
	ports_mcu();
	simulateur_use();
	lcd_init();
	periph_init();
	periph_nom("#AutoTest*");
	can_init();
	clavier_init(1);
	capture_init();
	sta_cyc(ID_acqui);
	sta_tsk(ID_periph_rx);
	sta_tsk(ID_infopiste);
	dly_tsk(1000);
	sta_tsk(ID_depart);
	sta_tsk(ID_regu);
	dly_tsk(2000);
	sta_tsk(ID_regu_roue);
	sta_tsk(ID_aff);
	//sta_tsk(ID_capt);
	sta_tsk(ID_urg);
	//sta_tsk(ID_infotps);
	while(1)
	{
	}
}

void acqui()
{
	LED_V=!LED_V;
}


